<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/canvas/canvas.js - xeogl</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 style="color:white;"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
                                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
                                <li><a href="../classes/Billboard.html">Billboard</a></li>
                                <li><a href="../classes/Boundary2D.html">Boundary2D</a></li>
                                <li><a href="../classes/Boundary3D.html">Boundary3D</a></li>
                                <li><a href="../classes/BoundingSphereGeometry.html">BoundingSphereGeometry</a></li>
                                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
                                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
                                <li><a href="../classes/Camera.html">Camera</a></li>
                                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
                                <li><a href="../classes/CameraController.html">CameraController</a></li>
                                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
                                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
                                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
                                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
                                <li><a href="../classes/Canvas.html">Canvas</a></li>
                                <li><a href="../classes/Clip.html">Clip</a></li>
                                <li><a href="../classes/Clips.html">Clips</a></li>
                                <li><a href="../classes/ColorBuf.html">ColorBuf</a></li>
                                <li><a href="../classes/Component.html">Component</a></li>
                                <li><a href="../classes/Configs.html">Configs</a></li>
                                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
                                <li><a href="../classes/Cull.html">Cull</a></li>
                                <li><a href="../classes/Curve.html">Curve</a></li>
                                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
                                <li><a href="../classes/DepthBuf.html">DepthBuf</a></li>
                                <li><a href="../classes/DirLight.html">DirLight</a></li>
                                <li><a href="../classes/Entity.html">Entity</a></li>
                                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
                                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
                                <li><a href="../classes/HeightmapGeometry.html">HeightmapGeometry</a></li>
                                <li><a href="../classes/Input.html">Input</a></li>
                                <li><a href="../classes/KeyboardAxisCamera.html">KeyboardAxisCamera</a></li>
                                <li><a href="../classes/KeyboardPanCamera.html">KeyboardPanCamera</a></li>
                                <li><a href="../classes/KeyboardRotateCamera.html">KeyboardRotateCamera</a></li>
                                <li><a href="../classes/KeyboardZoomCamera.html">KeyboardZoomCamera</a></li>
                                <li><a href="../classes/Layer.html">Layer</a></li>
                                <li><a href="../classes/Lights.html">Lights</a></li>
                                <li><a href="../classes/Lookat.html">Lookat</a></li>
                                <li><a href="../classes/Material.html">Material</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/Modes.html">Modes</a></li>
                                <li><a href="../classes/MousePanCamera.html">MousePanCamera</a></li>
                                <li><a href="../classes/MousePickEntity.html">MousePickEntity</a></li>
                                <li><a href="../classes/MouseRotateCamera.html">MouseRotateCamera</a></li>
                                <li><a href="../classes/MouseZoomCamera.html">MouseZoomCamera</a></li>
                                <li><a href="../classes/Nintendo3DSGeometry.html">Nintendo3DSGeometry</a></li>
                                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
                                <li><a href="../classes/OBJGeometry.html">OBJGeometry</a></li>
                                <li><a href="../classes/Ortho.html">Ortho</a></li>
                                <li><a href="../classes/Path.html">Path</a></li>
                                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
                                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
                                <li><a href="../classes/PointLight.html">PointLight</a></li>
                                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
                                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
                                <li><a href="../classes/Rotate.html">Rotate</a></li>
                                <li><a href="../classes/Scale.html">Scale</a></li>
                                <li><a href="../classes/Scene.html">Scene</a></li>
                                <li><a href="../classes/Skybox.html">Skybox</a></li>
                                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
                                <li><a href="../classes/Spinner.html">Spinner</a></li>
                                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
                                <li><a href="../classes/Stage.html">Stage</a></li>
                                <li><a href="../classes/Stationary.html">Stationary</a></li>
                                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
                                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
                                <li><a href="../classes/Texture.html">Texture</a></li>
                                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/Translate.html">Translate</a></li>
                                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
                                <li><a href="../classes/Viewport.html">Viewport</a></li>
                                <li><a href="../classes/Visibility.html">Visibility</a></li>
                                <li><a href="../classes/xeogl.html">xeogl</a></li>
                                <li><a href="../classes/xeogl.math.math.html">xeogl.math.math</a></li>
                                <li><a href="../classes/ZSpaceEffect.html">ZSpaceEffect</a></li>
                                <li><a href="../classes/ZSpaceStylusControl.html">ZSpaceStylusControl</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="..//modules/animation.html">animation</a></li>
                                <li><a href="..//modules/boundaries.html">boundaries</a></li>
                                <li><a href="..//modules/camera.html">camera</a></li>
                                <li><a href="..//modules/canvas.html">canvas</a></li>
                                <li><a href="..//modules/clipping.html">clipping</a></li>
                                <li><a href="..//modules/configs.html">configs</a></li>
                                <li><a href="..//modules/controls.html">controls</a></li>
                                <li><a href="..//modules/culling.html">culling</a></li>
                                <li><a href="..//modules/curves.html">curves</a></li>
                                <li><a href="..//modules/effects.html">effects</a></li>
                                <li><a href="..//modules/entities.html">entities</a></li>
                                <li><a href="..//modules/generation.html">generation</a></li>
                                <li><a href="..//modules/geometry.html">geometry</a></li>
                                <li><a href="..//modules/input.html">input</a></li>
                                <li><a href="..//modules/interaction.html">interaction</a></li>
                                <li><a href="..//modules/lighting.html">lighting</a></li>
                                <li><a href="..//modules/materials.html">materials</a></li>
                                <li><a href="..//modules/math.html">math</a></li>
                                <li><a href="..//modules/models.html">models</a></li>
                                <li><a href="..//modules/rendering.html">rendering</a></li>
                                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
                                <li><a href="..//modules/transforms.html">transforms</a></li>
                                <li><a href="..//modules/xeogl.html">xeogl</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
                    <!--Show:-->
                    <!--<label for="api-show-inherited">-->
                        <!--<input type="checkbox" id="api-show-inherited" checked>-->
                        <!--Inherited-->
                    <!--</label>-->
            
                    <!--<label for="api-show-protected">-->
                        <!--<input type="checkbox" id="api-show-protected">-->
                        <!--Protected-->
                    <!--</label>-->
            
                    <!--<label for="api-show-private">-->
                        <!--<input type="checkbox" id="api-show-private">-->
                        <!--Private-->
                    <!--</label>-->
                    <!--<label for="api-show-deprecated">-->
                        <!--<input type="checkbox" id="api-show-deprecated">-->
                        <!--Deprecated-->
                    <!--</label>-->
            
                <!--</div>-->
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/canvas/canvas.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 A **Canvas** manages a {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}&#x27;s HTML canvas and its WebGL context.

 ## Overview

 * Each {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} provides a Canvas as a read-only property on itself.
 * When a {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} is configured with the ID of
 an existing &lt;a href=&quot;http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element&quot;&gt;HTMLCanvasElement&lt;/a&gt;, then
 the Canvas will bind to that, otherwise the Canvas will automatically create its own.
 * A Canvas will fire a {{#crossLink &quot;Canvas/boundary:event&quot;}}{{/crossLink}} event whenever
 the &lt;a href=&quot;http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element&quot;&gt;HTMLCanvasElement&lt;/a&gt; resizes.
 * A Canvas is responsible for obtaining a WebGL context from
 the &lt;a href=&quot;http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element&quot;&gt;HTMLCanvasElement&lt;/a&gt;.
 * A Canvas also fires a {{#crossLink &quot;Canvas/webglContextLost:event&quot;}}{{/crossLink}} event when the WebGL context is
 lost, and a {{#crossLink &quot;Canvas/webglContextRestored:event&quot;}}{{/crossLink}} when it is restored again.
 * The various components within the parent {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} will transparently recover on
 the {{#crossLink &quot;Canvas/webglContextRestored:event&quot;}}{{/crossLink}} event.

 &lt;img src=&quot;../../../assets/images/Canvas.png&quot;&gt;&lt;/img&gt;

 Note that a Canvas also has a {{#crossLink &quot;Spinner&quot;}}{{/crossLink}}, which shows a
 busy spinner when a {{#crossLink &quot;Model&quot;}}{{/crossLink}} is loading, or when directed by application logic.

 ## Examples

 * [Multiple canvases/scenes in a page](../../examples/#scene_multipleScenes)
 * [Taking canvas snapshots](../../examples/#canvas_snapshot)
 * [Transparent canvas with background image](../../examples/#canvas_transparent)
 * [Canvas with multiple viewports](../../examples/#canvas_multipleViewports)

 ## Usage

 In the example below, we&#x27;re creating a {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}} without specifying an HTML canvas element
 for it. This causes the {{#crossLink &quot;Scene&quot;}}Scene{{/crossLink}}&#x27;s Canvas component to create its own default element
 within the page. Then we subscribe to various events fired by that Canvas component.

 &#x60;&#x60;&#x60;&#x60; javascript
 var scene = new xeogl.Scene();

 // Get the Canvas off the Scene
 // Since we did not configure the Scene with the ID of a DOM canvas element,
 // the Canvas will create its own canvas element in the DOM
 var canvas = scene.canvas;

 // Get the WebGL context off the Canvas
 var gl = canvas.gl;

 // Subscribe to Canvas size updates
 canvas.on(&quot;size&quot;, function(e) {
        var width = e.width;
        var height = e.height;
        var aspect = e.aspect;
        //...
     });

 // Subscribe to WebGL context loss events on the Canvas
 canvas.on(&quot;webglContextLost&quot;, function() {
        //...
     });

 // Subscribe to WebGL context restored events on the Canvas
 canvas.on(&quot;webglContextRestored&quot;, function(gl) {
        var newContext = gl;
        //...
     });
 &#x60;&#x60;&#x60;&#x60;

 When we want to bind the Canvas to an existing HTML canvas element, configure the
 {{#crossLink &quot;Scene&quot;}}{{/crossLink}} with the ID of the element, like this:

 &#x60;&#x60;&#x60;&#x60; javascript
 // Create a Scene, this time configuring it with the
 // ID of an existing DOM canvas element
 var scene = new xeogl.Scene({
          canvasId: &quot;myCanvas&quot;
     });

 // ..and the rest of this example can be the same as the previous example.

 &#x60;&#x60;&#x60;&#x60;

 The {{#crossLink &quot;Scene&quot;}}{{/crossLink}} will attempt to get use WebGL 2, or fall back on WebGL 1
 if that&#x27;s absent. If you just want WebGL 1, disable WebGL 2 like so:

 &#x60;&#x60;&#x60;&#x60; javascript
 var scene = new xeogl.Scene({
          canvasId: &quot;myCanvas&quot;,
          webgl2 : true
     });

 // ..and the rest of this example can be the same as the previous examples.

 &#x60;&#x60;&#x60;&#x60;


 @class Canvas
 @module xeogl
 @submodule canvas
 @static
 @param {Scene} scene Parent scene
 @extends Component
 */
(function () {

    &quot;use strict&quot;;

    xeogl.Canvas = xeogl.Component.extend({

        type: &quot;xeogl.Canvas&quot;,

        serializable: false,

        // Names of recognised WebGL contexts
        _WEBGL_CONTEXT_NAMES: [
            &quot;webgl&quot;,
            &quot;experimental-webgl&quot;,
            &quot;webkit-3d&quot;,
            &quot;moz-webgl&quot;,
            &quot;moz-glweb20&quot;
        ],

        _init: function (cfg) {

            /**
             * The HTML canvas. When the {{#crossLink &quot;Viewer&quot;}}{{/crossLink}} was configured with the ID of an existing canvas within the DOM,
             * then this property will be that element, otherwise it will be a full-page canvas that this Canvas has
             * created by default, with a z-index of -10000.
             *
             * @property canvas
             * @type {HTMLCanvasElement}
             * @final
             */
            this.canvas = null;

            /**
             * A transparent HTML DIV overlaid over the {{#crossLink &quot;Canvas/canvas:property&quot;}}{{/crossLink}}, with a z-index
             * of 100000.
             *
             * The parent {{#crossLink &quot;Scene&quot;}}{{/crossLink}}&#x27;s {{#crossLink &quot;Input&quot;}}{{/crossLink}} will relay mouse
             * events from this DIV, instead of from the {{#crossLink &quot;Canvas/canvas:property&quot;}}{{/crossLink}}.
             *
             * When you need to have various HTML elements floating around over
             * the {{#crossLink &quot;Canvas/canvas:property&quot;}}{{/crossLink}}, then if you give those a z-index that lies between
             * that of the {{#crossLink &quot;Canvas/canvas:property&quot;}}{{/crossLink}} and this DIV, your elements will not
             * interfere with those events.
             *
             * @property canvas
             * @type {HTMLCanvasElement}
             * @final
             */
            this.overlay = null;

            /**
             * The WebGL rendering context.
             *
             * @property gl
             * @type {WebGLRenderingContext}
             * @final
             */
            this.gl = null;

            /**
             * True when WebGL 2 support is enabled.
             *
             * @property webgl2
             * @type {Boolean}
             * @final
             */
            this.webgl2 = false; // Will set true in _initWebGL if WebGL is requested and we succeed in getting it.

            /**
             * Indicates whether this Canvas is transparent.
             *
             * @property transparent
             * @type {Boolean}
             * @default {false}
             * @final
             */
            this.transparent = !!cfg.transparent;

            /**
             * Attributes for the WebGL context
             *
             * @type {{}|*}
             */
            this.contextAttr = cfg.contextAttr || {};
            this.contextAttr.alpha = this.transparent;
            this.contextAttr.preserveDrawingBuffer = false;

            if (!cfg.canvas) {

                // Canvas not supplied, create one automatically

                this._createCanvas();

            } else {

                // Canvas supplied

                if (xeogl._isString(cfg.canvas)) {

                    // Canvas ID supplied - find the canvas

                    this.canvas = document.getElementById(cfg.canvas);

                    if (!this.canvas) {

                        // Canvas not found - create one automatically

                        this.error(&quot;Canvas element not found: &quot; + xeogl._inQuotes(cfg.canvas)
                            + &quot; - creating default canvas instead.&quot;);

                        this._createCanvas();
                    }

                } else {

                    this.canvas = cfg.canvas;
                }
            }

            if (!this.canvas) {

                this.error(&quot;Faied to create canvas&quot;);

                return;
            }

            // If the canvas uses css styles to specify the sizes make sure the basic
            // width and height attributes match or the WebGL context will use 300 x 150

            this.canvas.width = this.canvas.clientWidth;
            this.canvas.height = this.canvas.clientHeight;

            /**
             * Boundary of the Canvas in absolute browser window coordinates.
             *
             * ### Usage:
             *
             * &#x60;&#x60;&#x60;&#x60;javascript
             * var boundary = myScene.canvas.boundary;
             *
             * var xmin = boundary[0];
             * var ymin = boundary[1];
             * var width = boundary[2];
             * var height = boundary[3];
             * &#x60;&#x60;&#x60;&#x60;
             *
             * @property boundary
             * @type {{Array of Number}}
             * @final
             */
            this.boundary = [
                this.canvas.offsetLeft, this.canvas.offsetTop,
                this.canvas.clientWidth, this.canvas.clientHeight
            ];

            this._createBackground();
            this._createOverlay();

            this._resizeBackground();
            this._resizeOverlay();

            // Get WebGL context

            this._initWebGL(cfg);

            // Bind context loss and recovery handlers

            var self = this;

            this.canvas.addEventListener(&quot;webglcontextlost&quot;,
                function () {

                    /**
                     * Fired whenever the WebGL context has been lost
                     * @event webglContextLost
                     */
                    self.fire(&quot;webglContextLost&quot;);
                },
                false);

            this.canvas.addEventListener(&quot;webglcontextrestored&quot;,
                function () {
                    self._initWebGL();
                    if (self.gl) {

                        /**
                         * Fired whenever the WebGL context has been restored again after having previously being lost
                         * @event webglContextRestored
                         * @param value The WebGL context object
                         */
                        self.fire(&quot;webglContextRestored&quot;, self.gl);
                    }
                },
                false);

            // Publish canvas size and position changes on each scene tick

            var lastWindowWidth = null;
            var lastWindowHeight = null;

            var lastCanvasWidth = null;
            var lastCanvasHeight = null;

            var lastCanvasOffsetLeft = null;
            var lastCanvasOffsetTop = null;

            this._tick = this.scene.on(&quot;tick&quot;,
                function () {

                    var canvas = self.canvas;

                    var newWindowSize = (window.innerWidth !== lastWindowWidth || window.innerHeight !== lastWindowHeight);
                    var newCanvasSize = (canvas.clientWidth !== lastCanvasWidth || canvas.clientHeight !== lastCanvasHeight);
                    var newCanvasPos = (canvas.offsetLeft !== lastCanvasOffsetLeft || canvas.offsetTop !== lastCanvasOffsetTop);

                    if (newWindowSize || newCanvasSize || newCanvasPos) {

                        self._spinner._adjustPosition();

                        self._resizeBackground();
                        self._resizeOverlay();

                        if (newCanvasSize) {

                            var newWidth = canvas.clientWidth;
                            var newHeight = canvas.clientHeight;

                            // TODO: Wasteful to re-count pixel size of each canvas on each canvas&#x27; resize
                            var countPixels = 0;
                            var scene;
                            for (var sceneId in xeogl.scenes) {
                                if (xeogl.scenes.hasOwnProperty(sceneId)) {
                                    scene = xeogl.scenes[sceneId];
                                    countPixels += scene.canvas.canvas.clientWidth * scene.canvas.canvas.clientHeight;
                                }
                            }
                            xeogl.stats.memory.pixels = countPixels;

                            canvas.width = canvas.clientWidth;
                            canvas.height = canvas.clientHeight;

                            var boundary = self.boundary;

                            boundary[0] = canvas.offsetLeft;
                            boundary[1] = canvas.offsetTop;
                            boundary[2] = newWidth;
                            boundary[3] = newHeight;

                            /**
                             * Fired whenever this Canvas&#x27;s {{#crossLink &quot;Canvas/boundary:property&quot;}}{{/crossLink}} property changes.
                             *
                             * @event boundary
                             * @param value The property&#x27;s new value
                             */
                            self.fire(&quot;boundary&quot;, boundary);

                            lastCanvasWidth = newWidth;
                            lastCanvasHeight = newHeight;

                            lastWindowWidth = window.innerWidth;
                            lastWindowHeight = window.innerHeight;
                        }
                    }
                });

            this.canvas.oncontextmenu = function (e) {
                e.preventDefault();
            };

            /**
             *
             */
            this._spinner = new xeogl.Spinner(this.scene, {
                canvas: this.canvas
            });

            // Set property, see definition further down
            this.backgroundColor = cfg.backgroundColor;
            this.backgroundImage = cfg.backgroundImage;
        },

        /**
         * Creates a default canvas in the DOM.
         * @private
         */
        _createCanvas: function () {

            var canvasId = &quot;xeogl-canvas-&quot; + xeogl.math.createUUID();
            var body = document.getElementsByTagName(&quot;body&quot;)[0];
            var div = document.createElement(&#x27;div&#x27;);

            var style = div.style;
            style.height = &quot;100%&quot;;
            style.width = &quot;100%&quot;;
            style.padding = &quot;0&quot;;
            style.margin = &quot;0&quot;;
            style.background = &quot;rgba(0,0,0,0);&quot;;
            style.float = &quot;left&quot;;
            style.left = &quot;0&quot;;
            style.top = &quot;0&quot;;
            style.position = &quot;absolute&quot;;
            style.opacity = &quot;1.0&quot;;
            style[&quot;z-index&quot;] = &quot;-10000&quot;;

            div.innerHTML += &#x27;&lt;canvas id=&quot;&#x27; + canvasId + &#x27;&quot; style=&quot;width: 100%; height: 100%; float: left; margin: 0; padding: 0;&quot;&gt;&lt;/canvas&gt;&#x27;;

            body.appendChild(div);

            this.canvas = document.getElementById(canvasId);
        },

        /**
         * Creates a image element behind the canvas, for purpose of showing a custom background.
         * @private
         */
        _createBackground: function () {

            var body = document.getElementsByTagName(&quot;body&quot;)[0];
            var div = document.createElement(&#x27;div&#x27;);

            var style = div.style;
            style.padding = &quot;0&quot;;
            style.margin = &quot;0&quot;;
            style.background = null;
            style.backgroundImage = null;
            style.float = &quot;left&quot;;
            style.left = &quot;0&quot;;
            style.top = &quot;0&quot;;
            style.width = &quot;0px&quot;;
            style.height = &quot;0px&quot;;
            style.position = &quot;absolute&quot;;
            style.opacity = 1;
            style[&quot;z-index&quot;] = &quot;-20000&quot;;

            body.appendChild(div);

            this._backgroundElement = div;
        },

        /**
         * Creates an invisible DIV over the canvas, for purpose of catching
         * input events without interfering with app-lever UI bits floating underneath.
         * @private
         */
        _createOverlay: function () {

            var body = document.getElementsByTagName(&quot;body&quot;)[0];
            var div = document.createElement(&#x27;div&#x27;);

            var style = div.style;
            style.padding = &quot;0&quot;;
            style.margin = &quot;0&quot;;
            style.background = &quot;black&quot;;
            style.float = &quot;left&quot;;
            style.left = &quot;0&quot;;
            style.top = &quot;0&quot;;
            style.width = &quot;0px&quot;;
            style.height = &quot;0px&quot;;
            style.position = &quot;absolute&quot;;
            style.opacity = 0;
            style[&quot;z-index&quot;] = &quot;100000&quot;;

            body.appendChild(div);

            this.overlay = div;
        },

        /** (Re)sizes the overlay DIV to the canvas size
         * @private
         */
        _resizeOverlay: function () {

            if (!this.canvas || !this.overlay) {
                return;
            }

            var canvas = this.canvas;
            var overlay = this.overlay;
            var overlayStyle = overlay.style;

            var xy = this._getElementXY(canvas);
            overlayStyle[&quot;left&quot;] = xy.x + &quot;px&quot;;
            overlayStyle[&quot;top&quot;] = xy.y + &quot;px&quot;;
            overlayStyle[&quot;width&quot;] = canvas.clientWidth + &quot;px&quot;;
            overlayStyle[&quot;height&quot;] = canvas.clientHeight + &quot;px&quot;;
        },

        /** (Re)sizes the background DIV to the canvas size
         * @private
         */
        _resizeBackground: function () {

            if (!this.canvas || !this._backgroundElement) {
                return;
            }

            var canvas = this.canvas;
            var background = this._backgroundElement;
            var backgroundStyle = background.style;

            var xy = this._getElementXY(canvas);
            backgroundStyle[&quot;left&quot;] = xy.x + &quot;px&quot;;
            backgroundStyle[&quot;top&quot;] = xy.y + &quot;px&quot;;
            backgroundStyle[&quot;width&quot;] = canvas.clientWidth + &quot;px&quot;;
            backgroundStyle[&quot;height&quot;] = canvas.clientHeight + &quot;px&quot;;
        },

        _getElementXY: function (e) {
            var x = 0, y = 0;
            while (e) {
                x += e.offsetLeft;
                y += e.offsetTop;
                e = e.offsetParent;
            }
            return {x: x, y: y};
        },

        /**
         * Initialises the WebGL context
         * @private
         */
        _initWebGL: function (cfg) {

            // Default context attribute values

            if (cfg.webgl2) {
                try {
                    this.gl = this.canvas.getContext(&quot;webgl2&quot;, this.contextAttr);
                } catch (e) { // Try with next context name
                }
                if (!this.gl) {
                    this.warn(&#x27;Failed to get a WebGL 2 context - defaulting to WebGL 1.&#x27;);
                } else {
                    this.webgl2 = true;
                }
            }

            if (!this.gl) {
                for (var i = 0; !this.gl &amp;&amp; i &lt; this._WEBGL_CONTEXT_NAMES.length; i++) {
                    try {
                        this.gl = this.canvas.getContext(this._WEBGL_CONTEXT_NAMES[i], this.contextAttr);
                    } catch (e) { // Try with next context name
                    }
                }
            }

            if (!this.gl) {

                this.error(&#x27;Failed to get a WebGL context&#x27;);

                /**
                 * Fired whenever the canvas failed to get a WebGL context, which probably means that WebGL
                 * is either unsupported or has been disabled.
                 * @event webglContextFailed
                 */
                this.fire(&quot;webglContextFailed&quot;, true, true);
            }
        },

        /**
         Returns a snapshot of this Canvas as a Base64-encoded image.

         #### Usage:
         &#x60;&#x60;&#x60;&#x60;javascript
         imageElement.src = myScene.canvas.getSnapshot({
             width: 500, // Defaults to size of canvas
             height: 500,
             format: &quot;png&quot; // Options are &quot;jpeg&quot; (default), &quot;png&quot; and &quot;bmp&quot;
         });
         &#x60;&#x60;&#x60;&#x60;

         @method getSnapshot
         @param {*} [params] Capture options.
         @param {Number} [params.width] Desired width of result in pixels - defaults to width of canvas.
         @param {Number} [params.height] Desired height of result in pixels - defaults to height of canvas.
         @param {String} [params.format=&quot;jpeg&quot;] Desired format; &quot;jpeg&quot;, &quot;png&quot; or &quot;bmp&quot;.
         @returns {String} String-encoded image data.
         */
        getSnapshot: function (params) {

            if (!this.canvas) {
                this.error(&quot;Can&#x27;t get snapshot - no canvas.&quot;);
                return;
            }

            // Force-render a frame
            this.scene.render();

            params = params || {};

            var width = params.width || this.canvas.width;
            var height = params.height || this.canvas.height;
            var format = params.format || &quot;jpeg&quot;;
            var image;

            switch (format) {
                case &quot;jpeg&quot;:
                    image = Canvas2Image.saveAsJPEG(this.canvas, true, width, height);
                    break;

                case &quot;png&quot;:
                    image = Canvas2Image.saveAsPNG(this.canvas, true, width, height);
                    break;

                case &quot;bmp&quot;:
                    image = Canvas2Image.saveAsBMP(this.canvas, true, width, height);
                    break;

                default:
                    this.error(&quot;Unsupported snapshot format: &#x27;&quot; + format
                        + &quot;&#x27; - supported types are &#x27;jpeg&#x27;, &#x27;bmp&#x27; and &#x27;png&#x27; - defaulting to &#x27;jpeg&#x27;&quot;);
                    image = Canvas2Image.saveAsJPEG(this.canvas, true, width, height);
            }

            return image.src;
        },

        /**
         Reads colors of pixels from the last rendered frame.

         &lt;p&gt;Call this method like this:&lt;/p&gt;

         &#x60;&#x60;&#x60;&#x60;JavaScript

         // Ignore transparent pixels (default is false)
         var opaqueOnly = true;

         var colors = new Float32Array(8);

         myCanvas.readPixels([ 100, 22, 12, 33 ], colors, 2, opaqueOnly);
         &#x60;&#x60;&#x60;&#x60;

         Then the r,g,b components of the colors will be set to the colors at those pixels.

         @param {Float32Array} pixels
         @param {Float32Array} colors
         @param {Number} size
         @param {Boolean} opaqueOnly
         */
        readPixels: function (pixels, colors, size, opaqueOnly) {
            return this.scene._renderer.readPixels(pixels, colors, size, opaqueOnly);
        },

        _props: {

            /**
             A background color for the canvas. This is overridden by {{#crossLink &quot;Canvas/backgroundImage:property&quot;}}{{/crossLink}}.

             You can set this to a new color at any time.

             Fires a {{#crossLink &quot;Canvas/backgroundColor:event&quot;}}{{/crossLink}} event on change.

             @property backgroundColor
             @type Float32Array
             @default null
             */
            backgroundColor: {

                set: function (value) {

                    if (!value) {

                        this._backgroundColor = null;

                    } else {

                        (this._backgroundColor = this._backgroundColor || new xeogl.math.vec4()).set(value || [0, 0, 0, 1]);

                        if (!this._backgroundImageSrc) {
                            var rgb = &quot;rgb(&quot; + Math.round(this._backgroundColor[0] * 255) + &quot;, &quot; + Math.round(this._backgroundColor[1] * 255) + &quot;,&quot; + Math.round(this._backgroundColor[2] * 255) + &quot;)&quot;;
                            this._backgroundElement.style.background = rgb;
                        }
                    }

                    /**
                     Fired whenever this Canvas&#x27;s {{#crossLink &quot;Canvas/backgroundColor:property&quot;}}{{/crossLink}} property changes.
                     @event backgroundColor
                     @param value The property&#x27;s new value
                     */
                    this.fire(&quot;backgroundColor&quot;, this._backgroundColor);
                },

                get: function () {
                    return this._backgroundColor;
                }
            },

            /**
             URL of a background image for the canvas. This is overrided by {{#crossLink &quot;Canvas/backgroundColor/property&quot;}}{{/crossLink}}.

             You can set this to a new file path at any time.

             Fires a {{#crossLink &quot;Canvas/background:event&quot;}}{{/crossLink}} event on change.

             @property backgroundImage
             @type String
             */
            backgroundImage: {

                set: function (value) {

                    if (!value) {
                        return;
                    }

                    if (!xeogl._isString(value)) {
                        this.error(&quot;Value for &#x27;backgroundImage&#x27; should be a string&quot;);
                        return;
                    }

                    if (value === this._backgroundImageSrc) { // Already loaded this image
                        return;
                    }

                    this._backgroundElement.style.backgroundImage = &quot;url(&#x27;&quot; + value + &quot;&#x27;)&quot;;
                    this._backgroundImageSrc = value;

                    if (!this._backgroundImageSrc) {
                        var rgb = &quot;rgb(&quot; + Math.round(this._backgroundColor[0] * 255) + &quot;, &quot; + Math.round(this._backgroundColor[1] * 255) + &quot;,&quot; + Math.round(this._backgroundColor[2] * 255) + &quot;)&quot;;
                        this._backgroundElement.style.background = rgb;
                    }

                    /**
                     Fired whenever this Canvas&#x27;s {{#crossLink &quot;Canvas/backgroundImage:property&quot;}}{{/crossLink}} property changes.
                     @event backgroundImage
                     @param value The property&#x27;s new value
                     */
                    this.fire(&quot;backgroundImage&quot;, this._backgroundImageSrc);
                },

                get: function () {
                    return this._backgroundImageSrc;
                }
            },

            /**
             The busy {{#crossLink &quot;Spinner&quot;}}{{/crossLink}} for this Canvas.

             @property spinner
             @type Spinner
             @final
             */
            spinner: {

                get: function () {
                    return this._spinner;
                }
            }
        },

        _destroy: function () {
            this.scene.off(this._tick);
        }
    });

})();

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
