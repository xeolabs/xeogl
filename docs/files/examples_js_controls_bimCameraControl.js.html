<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>examples/js/controls/bimCameraControl.js - xeogl</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link href='https://fonts.googleapis.com/css?family=Exo+2:400,800,900,700,600,500|Roboto:100,300,400,500,700,900'  rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 class="projectTitle"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
                                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
                                <li><a href="../classes/Billboard.html">Billboard</a></li>
                                <li><a href="../classes/Boundary2D.html">Boundary2D</a></li>
                                <li><a href="../classes/Boundary3D.html">Boundary3D</a></li>
                                <li><a href="../classes/BoundingSphereGeometry.html">BoundingSphereGeometry</a></li>
                                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
                                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
                                <li><a href="../classes/Camera.html">Camera</a></li>
                                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
                                <li><a href="../classes/CameraController.html">CameraController</a></li>
                                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
                                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
                                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
                                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
                                <li><a href="../classes/Canvas.html">Canvas</a></li>
                                <li><a href="../classes/Clip.html">Clip</a></li>
                                <li><a href="../classes/Clips.html">Clips</a></li>
                                <li><a href="../classes/ColorBuf.html">ColorBuf</a></li>
                                <li><a href="../classes/Component.html">Component</a></li>
                                <li><a href="../classes/Configs.html">Configs</a></li>
                                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
                                <li><a href="../classes/Cull.html">Cull</a></li>
                                <li><a href="../classes/Curve.html">Curve</a></li>
                                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
                                <li><a href="../classes/DepthBuf.html">DepthBuf</a></li>
                                <li><a href="../classes/DirLight.html">DirLight</a></li>
                                <li><a href="../classes/Entity.html">Entity</a></li>
                                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
                                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
                                <li><a href="../classes/HeightmapGeometry.html">HeightmapGeometry</a></li>
                                <li><a href="../classes/Input.html">Input</a></li>
                                <li><a href="../classes/KeyboardAxisCamera.html">KeyboardAxisCamera</a></li>
                                <li><a href="../classes/KeyboardPanCamera.html">KeyboardPanCamera</a></li>
                                <li><a href="../classes/KeyboardRotateCamera.html">KeyboardRotateCamera</a></li>
                                <li><a href="../classes/KeyboardZoomCamera.html">KeyboardZoomCamera</a></li>
                                <li><a href="../classes/Layer.html">Layer</a></li>
                                <li><a href="../classes/Lights.html">Lights</a></li>
                                <li><a href="../classes/Lookat.html">Lookat</a></li>
                                <li><a href="../classes/Material.html">Material</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/Modes.html">Modes</a></li>
                                <li><a href="../classes/MousePanCamera.html">MousePanCamera</a></li>
                                <li><a href="../classes/MousePickEntity.html">MousePickEntity</a></li>
                                <li><a href="../classes/MouseRotateCamera.html">MouseRotateCamera</a></li>
                                <li><a href="../classes/MouseZoomCamera.html">MouseZoomCamera</a></li>
                                <li><a href="../classes/Nintendo3DSGeometry.html">Nintendo3DSGeometry</a></li>
                                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
                                <li><a href="../classes/OBJGeometry.html">OBJGeometry</a></li>
                                <li><a href="../classes/Ortho.html">Ortho</a></li>
                                <li><a href="../classes/Path.html">Path</a></li>
                                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
                                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
                                <li><a href="../classes/PointLight.html">PointLight</a></li>
                                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
                                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
                                <li><a href="../classes/Rotate.html">Rotate</a></li>
                                <li><a href="../classes/Scale.html">Scale</a></li>
                                <li><a href="../classes/Scene.html">Scene</a></li>
                                <li><a href="../classes/Skybox.html">Skybox</a></li>
                                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
                                <li><a href="../classes/Spinner.html">Spinner</a></li>
                                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
                                <li><a href="../classes/Stage.html">Stage</a></li>
                                <li><a href="../classes/Stationary.html">Stationary</a></li>
                                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
                                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
                                <li><a href="../classes/Texture.html">Texture</a></li>
                                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/Translate.html">Translate</a></li>
                                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
                                <li><a href="../classes/Viewport.html">Viewport</a></li>
                                <li><a href="../classes/Visibility.html">Visibility</a></li>
                                <li><a href="../classes/xeogl.html">xeogl</a></li>
                                <li><a href="../classes/xeogl.math.math.html">xeogl.math.math</a></li>
                                <li><a href="../classes/ZSpaceEffect.html">ZSpaceEffect</a></li>
                                <li><a href="../classes/ZSpaceStylusControl.html">ZSpaceStylusControl</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="..//modules/animation.html">animation</a></li>
                                <li><a href="..//modules/boundaries.html">boundaries</a></li>
                                <li><a href="..//modules/camera.html">camera</a></li>
                                <li><a href="..//modules/canvas.html">canvas</a></li>
                                <li><a href="..//modules/clipping.html">clipping</a></li>
                                <li><a href="..//modules/configs.html">configs</a></li>
                                <li><a href="..//modules/controls.html">controls</a></li>
                                <li><a href="..//modules/culling.html">culling</a></li>
                                <li><a href="..//modules/curves.html">curves</a></li>
                                <li><a href="..//modules/effects.html">effects</a></li>
                                <li><a href="..//modules/entities.html">entities</a></li>
                                <li><a href="..//modules/generation.html">generation</a></li>
                                <li><a href="..//modules/geometry.html">geometry</a></li>
                                <li><a href="..//modules/input.html">input</a></li>
                                <li><a href="..//modules/interaction.html">interaction</a></li>
                                <li><a href="..//modules/lighting.html">lighting</a></li>
                                <li><a href="..//modules/materials.html">materials</a></li>
                                <li><a href="..//modules/math.html">math</a></li>
                                <li><a href="..//modules/models.html">models</a></li>
                                <li><a href="..//modules/rendering.html">rendering</a></li>
                                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
                                <li><a href="..//modules/transforms.html">transforms</a></li>
                                <li><a href="..//modules/xeogl.html">xeogl</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
                    <!--Show:-->
                    <!--<label for="api-show-inherited">-->
                        <!--<input type="checkbox" id="api-show-inherited" checked>-->
                        <!--Inherited-->
                    <!--</label>-->
            
                    <!--<label for="api-show-protected">-->
                        <!--<input type="checkbox" id="api-show-protected">-->
                        <!--Protected-->
                    <!--</label>-->
            
                    <!--<label for="api-show-private">-->
                        <!--<input type="checkbox" id="api-show-private">-->
                        <!--Private-->
                    <!--</label>-->
                    <!--<label for="api-show-deprecated">-->
                        <!--<input type="checkbox" id="api-show-deprecated">-->
                        <!--Deprecated-->
                    <!--</label>-->
            
                <!--</div>-->
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: examples/js/controls/bimCameraControl.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function () {

    &quot;use strict&quot;;

    /**

     Controls camera with mouse and keyboard, handles selection of entities and rotation point.

     */
    xeogl.BIMCameraControl = xeogl.Component.extend({

        type: &quot;xeogl.BIMCameraControl&quot;,

        _init: function (cfg) {

            var self = this;

            var math = xeogl.math;

            // Configs

            var sensitivityKeyboardRotate = cfg.sensitivityKeyboardRotate || 0.5;

            var orthoScaleRate = 0.02; // Rate at which orthographic scale changes with zoom

            var canvasPickTolerance = 4;
            var worldPickTolerance = 3;

            var pitchMat = math.mat4();

            var camera = cfg.camera;
            var view = camera.view;
            var project = camera.project;
            var scene = this.scene;
            var input = scene.input;

            // Camera position on last mouse click
            var rotateStartEye;
            var rotateStartLook;
            var rotateStartUp = math.vec3();

            var orbitPitchAxis = math.vec3([1, 0, 0]); // The current axis for vertical orbit  

            var pickHit; // Hit record from the most recent pick
            var pickClicks = 0; // Number of times we&#x27;ve clicked on same spot on entity

            var mouseClickPos = math.vec2(); // Canvas position of last mouseDown
            var firstPickCanvasPos = math.vec2(); // Canvas position of first pick
            var firstPickWorldPos = math.vec2(); // World position of first pick
            var firstPickTime; // Time of first pick

            var rotatePos = this._rotatePos = math.vec3([0, 0, 0]); // World-space pivot point we&#x27;re currently rotating about

            var lastCanvasPos = math.vec2(); // Mouse&#x27;s position in previous tick
            var rotationDeltas = math.vec2(); // Accumulated angle deltas while rotating with keyboard or mouse

            var shiftDown = false; // True while shift key down
            var mouseDown = false; // true while mouse down

            var flying = false;

            var lastHoverDistance = null;

            // Returns the inverse of the camera&#x27;s current view transform matrix
            var getInverseViewMat = (function () {
                var viewMatDirty = true;
                camera.on(&quot;viewMatrix&quot;, function () {
                    viewMatDirty = true;
                });
                var inverseViewMat = math.mat4();
                return function () {
                    if (viewMatDirty) {
                        math.inverseMat4(view.matrix, inverseViewMat);
                    }
                    return inverseViewMat;
                }
            })();

            // Returns the inverse of the camera&#x27;s current projection transform matrix
            var getInverseProjectMat = (function () {
                var projMatDirty = true;
                camera.on(&quot;projectMatrix&quot;, function () {
                    projMatDirty = true;
                });
                var inverseProjectMat = math.mat4();
                return function () {
                    if (projMatDirty) {
                        math.inverseMat4(project.matrix, inverseProjectMat);
                    }
                    return inverseProjectMat;
                }
            })();

            // Returns the transposed copy the camera&#x27;s current projection transform matrix
            var getTransposedProjectMat = (function () {
                var projMatDirty = true;
                camera.on(&quot;projectMatrix&quot;, function () {
                    projMatDirty = true;
                });
                var transposedProjectMat = math.mat4();
                return function () {
                    if (projMatDirty) {
                        math.transposeMat4(project.matrix, transposedProjectMat);
                    }
                    return transposedProjectMat;
                }
            })();

            // Get the current diagonal size of the scene
            var getSceneDiagSize = (function () {
                var sceneSizeDirty = true;
                var diag = 1; // Just in case
                scene.worldBoundary.on(&quot;updated&quot;, function () {
                    sceneSizeDirty = true;
                });
                return function () {
                    if (sceneSizeDirty) {
                        diag = math.getAABB3Diag(scene.worldBoundary.aabb);
                    }
                    return diag;
                };
            })();

            var rotate = (function () {
                var tempVec3a = math.vec3();
                var tempVec3b = math.vec3();
                var tempVec3c = math.vec3();
                return function (p) {
                    var p1 = math.subVec3(p, rotatePos, tempVec3a);
                    var p2 = math.transformVec3(pitchMat, p1, tempVec3b);
                    var p3 = math.addVec3(p2, rotatePos, tempVec3c);
                    return math.rotateVec3Z(p3, rotatePos, -rotationDeltas[0] * math.DEGTORAD, math.vec3());
                };
            })();

            // Rotation point indicator

            var pickHelper = this.create({
                type: &quot;xeogl.Entity&quot;,
                geometry: this.create({
                    type: &quot;xeogl.SphereGeometry&quot;,
                    radius: 1.0
                }),
                material: this.create({
                    type: &quot;xeogl.PhongMaterial&quot;,
                    diffuse: [0, 0, 0],
                    ambient: [0, 0, 0],
                    specular: [0, 0, 0],
                    emissive: [1.0, 1.0, 0.6], // Glowing
                    lineWidth: 4
                }),
                transform: this.create({
                    type: &quot;xeogl.Translate&quot;,
                    xyz: [0, 0, 0]
                }),
                visibility: this.create({
                    type: &quot;xeogl.Visibility&quot;,
                    visible: false // Initially invisible
                }),
                modes: this.create({
                    type: &quot;xeogl.Modes&quot;,
                    collidable: false // This helper has no collision boundary of its own
                })
            });

            // Shows the rotation point indicator
            // at the given position for one second

            var showRotationPoint = (function () {

                var pickHelperHide = null;

                return function (pos) {

                    pickHelper.transform.xyz = pos;
                    pickHelper.visibility.visible = true;

                    if (pickHelperHide) {
                        clearTimeout(pickHelperHide);
                        pickHelperHide = null;
                    }

                    pickHelperHide = setTimeout(function () {
                            pickHelper.visibility.visible = false;
                            pickHelperHide = null;
                        },
                        1000)
                };
            })();


            var pickTimer;

            // Fires a &quot;pick&quot; after a timeout period unless clearPickTimer is called before then.
            function startPickTimer() {

                if (pickTimer) {
                    clearPickTimer();
                }

                pickTimer = setTimeout(function () {
                    pickClicks = 0;
                    self.fire(&quot;pick&quot;, pickHit);
                    pickTimer = null;
                }, 250);
            }

            // Stops a previous call to startPickTimer from firing a &quot;pick&quot;
            function clearPickTimer() {
                clearTimeout(pickTimer);
                pickTimer = null;
            }


            function resetRotate() {

                pickClicks = 0;

                rotationDeltas[0] = 0;
                rotationDeltas[1] = 0;

                rotateStartEye = view.eye.slice();
                rotateStartLook = view.look.slice();
                math.addVec3(rotateStartEye, view.up, rotateStartUp);

                setOrbitPitchAxis();
            }

            function setOrbitPitchAxis() {
                math.cross3Vec3(math.normalizeVec3(math.subVec3(view.eye, view.look, math.vec3())), view.up, orbitPitchAxis);
            }

            var setCursor = (function () {

                var t;

                return function (cursor, persist) {

                    clearTimeout(t);

                    self.scene.canvas.overlay.style[&quot;cursor&quot;] = cursor;

                    if (!persist) {
                        t = setTimeout(function () {
                            self.scene.canvas.overlay.style[&quot;cursor&quot;] = &quot;auto&quot;;
                        }, 100);
                    }
                };
            })();

            input.on(&quot;mousedown&quot;,
                function (canvasPos) {

                    canvasPos = canvasPos.slice();

                    if (!input.mouseover) {
                        return;
                    }

                    if (!input.mouseDownLeft) {
                        return;
                    }

                    if (flying) {
                        return;
                    }

                    clearPickTimer();

                    setOrbitPitchAxis();

                    rotateStartEye = view.eye.slice();
                    rotateStartLook = view.look.slice();
                    math.addVec3(rotateStartEye, view.up, rotateStartUp);

                    pickHit = scene.pick({
                        canvasPos: canvasPos,
                        pickSurface: true
                    });

                    if (pickHit &amp;&amp; pickHit.worldPos) {

                        var pickWorldPos = pickHit.worldPos.slice();
                        var pickCanvasPos = canvasPos;

                        var pickTime = Date.now();

                        if (pickClicks === 1) {

                            if ((pickTime - firstPickTime &lt; 250)
                                &amp;&amp; closeEnoughCanvas(canvasPos, firstPickCanvasPos)
                                &amp;&amp; closeEnoughWorld(pickWorldPos, firstPickWorldPos)) {

                                // Double-clicked

                                rotatePos.set(pickWorldPos);

                                showRotationPoint(pickWorldPos);
                            }

                            pickClicks = 0;

                        } else {

                            pickClicks = 1;

                            firstPickWorldPos = pickWorldPos;
                            firstPickCanvasPos = pickCanvasPos;
                            firstPickTime = pickTime;
                        }

                    } else {

                        pickClicks = 0;
                    }

                    mouseClickPos[0] = canvasPos[0];
                    mouseClickPos[1] = canvasPos[1];

                    rotationDeltas[0] = 0;
                    rotationDeltas[1] = 0;

                    mouseDown = true;
                });

            // Returns true if the two Canvas-space points are
            // close enough to be considered the same point

            function closeEnoughCanvas(p, q) {
                return p[0] &gt;= (q[0] - canvasPickTolerance) &amp;&amp;
                    p[0] &lt;= (q[0] + canvasPickTolerance) &amp;&amp;
                    p[1] &gt;= (q[1] - canvasPickTolerance) &amp;&amp;
                    p[1] &lt;= (q[1] + canvasPickTolerance);
            }

            // Returns true if the two World-space points are
            // close enough to be considered the same point

            function closeEnoughWorld(p, q) {
                return p[0] &gt;= (q[0] - worldPickTolerance) &amp;&amp;
                    p[0] &lt;= (q[0] + worldPickTolerance) &amp;&amp;
                    p[1] &gt;= (q[1] - worldPickTolerance) &amp;&amp;
                    p[1] &gt;= (q[1] - worldPickTolerance) &amp;&amp;
                    p[2] &lt;= (q[2] + worldPickTolerance) &amp;&amp;
                    p[2] &lt;= (q[2] + worldPickTolerance);
            }

            var tempVecHover = math.vec3();

            var updateHoverDistanceAndCursor = function(canvasPos) {

                console.log(&quot;updateHoverDistanceAndCursor&quot;);

                var hit = scene.pick({
                    canvasPos: canvasPos || lastCanvasPos,
                    pickSurface: true
                });

                if (hit) {
                    setCursor(&quot;pointer&quot;, true);
                    if (hit.worldPos) {
                        // TODO: This should be somehow hit.viewPos.z, but doesn&#x27;t seem to be
                        lastHoverDistance = math.lenVec3(math.subVec3(hit.worldPos, view.eye, tempVecHover));
                    }
                } else {
                    setCursor(&quot;auto&quot;, true);
                }
            };

            input.on(&quot;mousemove&quot;,
                function (canvasPos) {

                    if (!input.mouseover) {
                        return;
                    }

                    if (flying) {
                        return;
                    }

                    if (!mouseDown) {

                        updateHoverDistanceAndCursor(canvasPos);

                        lastCanvasPos[0] = canvasPos[0];
                        lastCanvasPos[1] = canvasPos[1];

                        return;
                    }

                    var sceneSize = getSceneDiagSize();

                    // Use normalized device coords
                    var canvas = scene.canvas.canvas;
                    var cw2 = canvas.offsetWidth / 2.;
                    var ch2 = canvas.offsetHeight / 2.;

                    var inverseProjMat = getInverseProjectMat();
                    var inverseViewMat = getInverseViewMat();

                    // Get last two columns of projection matrix
                    var transposedProjectMat = getTransposedProjectMat();
                    var Pt3 = transposedProjectMat.subarray(8, 12);
                    var Pt4 = transposedProjectMat.subarray(12);

                    // TODO: Should be simpler to get the projected Z value
                    var D = [0, 0, -(lastHoverDistance || sceneSize), 1];
                    var Z = math.dotVec4(D, Pt3) / math.dotVec4(D, Pt4);

                    // Returns in camera space and model space as array of two points
                    var unproject = function (p) {
                        var cp = math.vec4();
                        cp[0] = (p[0] - cw2) / cw2;
                        cp[1] = (p[1] - ch2) / ch2;
                        cp[2] = Z;
                        cp[3] = 1.;
                        cp = math.vec4(math.mulMat4v4(inverseProjMat, cp));

                        // Normalize homogeneous coord
                        math.mulVec3Scalar(cp, 1.0 / cp[3]);
                        cp[3] = 1.0;

                        // TODO: Why is this reversed?
                        cp[0] *= -1;

                        var cp2 = math.vec4(math.mulMat4v4(inverseViewMat, cp));
                        return [cp, cp2];
                    };

                    var A = unproject(canvasPos);
                    var B = unproject(lastCanvasPos);

                    var panning = input.keyDown[input.KEY_SHIFT] || input.mouseDownMiddle || (input.mouseDownLeft &amp;&amp; input.mouseDownRight);

                    if (panning) {
                        // TODO: view.pan is in view space? We have a world coord vector.

                        // Subtract model space unproject points
                        math.subVec3(A[1], B[1], tempVecHover);
                        view.eye = math.addVec3(view.eye, tempVecHover);
                        view.look = math.addVec3(view.look, tempVecHover);
                    } else {
                        // If not panning, we are orbiting                        

                        // Subtract camera space unproject points
                        math.subVec3(A[0], B[0], tempVecHover);

                        //           v because reversed above
                        var xDelta = - tempVecHover[0] * Math.PI;
                        var yDelta = tempVecHover[1] * Math.PI;

                        rotationDeltas[0] += xDelta;
                        rotationDeltas[1] += yDelta;

                        math.rotationMat4v(rotationDeltas[1] * math.DEGTORAD, orbitPitchAxis, pitchMat);

                        view.eye = rotate(rotateStartEye);
                        view.look = rotate(rotateStartLook);
                        view.up = math.subVec3(rotate(rotateStartUp), view.eye, math.vec3());
                    }

                    lastCanvasPos[0] = canvasPos[0];
                    lastCanvasPos[1] = canvasPos[1];
                });

            input.on(&quot;keydown&quot;,
                function (keyCode) {
                    if (keyCode === input.KEY_SHIFT) {
                        shiftDown = true;
                    }
                });

            input.on(&quot;keyup&quot;,
                function (keyCode) {
                    if (keyCode === input.KEY_SHIFT) {
                        shiftDown = false;
                        resetRotate();
                    }
                });

            input.on(&quot;mouseup&quot;,
                function (canvasPos) {

                    if (!mouseDown) {
                        return;
                    }

                    if (flying) {
                        return;
                    }

                    mouseDown = false;

                    if (input.mouseover) {

                        if (firstPickCanvasPos &amp;&amp; closeEnoughCanvas(canvasPos, firstPickCanvasPos)) {

                            if (pickClicks === 1) {

                                if (shiftDown) {

                                    pickClicks = 0;

                                    self.fire(&quot;pick&quot;, pickHit);

                                } else {
                                    startPickTimer();
                                }

                            } else {
                                //  self.fire(&quot;nopick&quot;);
                            }

                        } else if (pickClicks === 0) {

                            if (mouseClickPos &amp;&amp; closeEnoughCanvas(canvasPos, mouseClickPos)) {

                                self.fire(&quot;nopick&quot;);
                            }
                        }
                    }
                });

            input.on(&quot;dblclick&quot;,
                function () {

                    if (flying) {
                        return;
                    }

                    mouseDown = false;
                });

            //---------------------------------------------------------------------------------------------------------
            // Keyboard rotate camera
            //---------------------------------------------------------------------------------------------------------


            scene.on(&quot;tick&quot;,
                function (params) {

                    if (!input.mouseover) {
                        return;
                    }

                    if (mouseDown) {
                        return;
                    }

                    if (flying) {
                        return;
                    }

                    if (!input.ctrlDown &amp;&amp; !input.altDown) {

                        var left = input.keyDown[input.KEY_LEFT_ARROW];
                        var right = input.keyDown[input.KEY_RIGHT_ARROW];
                        var up = input.keyDown[input.KEY_UP_ARROW];
                        var down = input.keyDown[input.KEY_DOWN_ARROW];

                        if (left || right || up || down) {

                            var elapsed = params.deltaTime;
                            var yawRate = sensitivityKeyboardRotate * 0.3;
                            var pitchRate = sensitivityKeyboardRotate * 0.3;
                            var yaw = 0;
                            var pitch = 0;

                            if (right) {
                                yaw = -elapsed * yawRate;

                            } else if (left) {
                                yaw = elapsed * yawRate;
                            }

                            if (down) {
                                pitch = elapsed * pitchRate;

                            } else if (up) {
                                pitch = -elapsed * pitchRate;
                            }

                            if (Math.abs(yaw) &gt; Math.abs(pitch)) {
                                pitch = 0;
                            } else {
                                yaw = 0;
                            }

                            rotationDeltas[0] -= yaw;
                            rotationDeltas[1] += pitch;

                            math.rotationMat4v(rotationDeltas[1] * math.DEGTORAD, orbitPitchAxis, pitchMat);

                            view.eye = rotate(rotateStartEye);
                            view.look = rotate(rotateStartLook);
                            view.up = math.subVec3(rotate(rotateStartUp), view.eye, math.vec3());
                        }
                    }
                });


            //---------------------------------------------------------------------------------------------------------
            // Keyboard zoom camera
            //---------------------------------------------------------------------------------------------------------

            (function () {

                var tempVec3a = math.vec3();
                var tempVec3b = math.vec3();
                var tempVec3c = math.vec3();
                var eyePivotVec = math.vec3();

                scene.on(&quot;tick&quot;,
                    function (params) {

                        if (!input.mouseover) {
                            return;
                        }

                        if (mouseDown) {
                            return;
                        }

                        if (flying) {
                            return;
                        }

                        var elapsed = params.deltaTime;

                        if (!input.ctrlDown &amp;&amp; !input.altDown) {

                            var wkey = input.keyDown[input.KEY_ADD];
                            var skey = input.keyDown[input.KEY_SUBTRACT];

                            if (wkey || skey) {

                                var sceneSize = getSceneDiagSize();
                                var rate = sceneSize / 5000.0;

                                var delta = 0;

                                if (skey) {
                                    delta = elapsed * rate; // Want sensitivity configs in [0..1] range
                                } else if (wkey) {
                                    delta = -elapsed * rate;
                                }

                                var eye = view.eye;
                                var look = view.look;

                                // Get vector from eye to center of rotation
                                math.mulVec3Scalar(math.normalizeVec3(math.subVec3(eye, rotatePos, tempVec3a), tempVec3b), delta, eyePivotVec);

                                // Move eye and look along the vector
                                view.eye = math.addVec3(eye, eyePivotVec, tempVec3c);
                                view.look = math.addVec3(look, eyePivotVec, tempVec3c);

                                if (project.isType(&quot;xeogl.Ortho&quot;)) {
                                    project.scale += delta * orthoScaleRate;
                                }

                                resetRotate();
                            }
                        }
                    });
            })();

            //---------------------------------------------------------------------------------------------------------
            // Mouse zoom
            // Roll mouse wheel to move eye and look closer or further from center of rotationDeltas 
            //---------------------------------------------------------------------------------------------------------

            (function () {

                var delta = 0;
                var target = 0;
                var newTarget = false;
                var targeting = false;
                var progress = 0;

                var tempVec3a = math.vec3();
                var tempVec3b = math.vec3();
                var newEye = math.vec3();
                var newLook = math.vec3();
                var eyePivotVec = math.vec3();


                input.on(&quot;mousewheel&quot;,
                    function (_delta) {

                        if (mouseDown) {
                            return;
                        }

                        if (flying) {
                            return;
                        }

                        delta = -_delta;

                        if (delta === 0) {
                            targeting = false;
                            newTarget = false;
                        } else {
                            newTarget = true;
                        }
                    });

                var updateTimeout = null;

                scene.on(&quot;tick&quot;,
                    function (e) {

                        if (!targeting &amp;&amp; !newTarget) {
                            return;
                        }

                        if (mouseDown) {
                            return;
                        }

                        if (flying) {
                            return;
                        }

                        if (updateTimeout) {
                            clearTimeout(updateTimeout);
                        }
                        updateTimeout = setTimeout(function() {
                            updateHoverDistanceAndCursor();
                            updateTimeout = null;
                        }, 50);

                        var zoomTimeInSeconds = 0.2;
                        var viewDistance = getSceneDiagSize();
                        if (lastHoverDistance) {
                            viewDistance = viewDistance * 0.02 + lastHoverDistance;
                        }

                        var tickDeltaSecs = e.deltaTime / 1000.0;
                        var f = viewDistance * ((delta &lt; 0) ? -1 : 1) / zoomTimeInSeconds / 100.;

                        if (newTarget) {

                            target = zoomTimeInSeconds;

                            progress = 0;
                            newTarget = false;
                            targeting = true;
                        }

                        if (targeting) {

                            progress += tickDeltaSecs;

                            if (progress &gt; target) {
                                targeting = false;
                            }

                            if (targeting) {

                                var eye = view.eye;
                                var look = view.look;

                                math.mulVec3Scalar(xeogl.math.transposeMat4(view.matrix).slice(8), f, eyePivotVec);
                                math.addVec3(eye, eyePivotVec, newEye);
                                math.addVec3(look, eyePivotVec, newLook);

                                var lenEyePivotVec = Math.abs(math.lenVec3(eyePivotVec));
                                var currentEyePivotDist = Math.abs(math.lenVec3(math.subVec3(eye, rotatePos, math.vec3())));

                                // if (lenEyePivotVec &lt; currentEyePivotDist - 10) {

                                // Move eye and look along the vector
                                view.eye = newEye;
                                view.look = newLook;

                                if (project.isType(&quot;xeogl.Ortho&quot;)) {
                                    project.scale += delta * orthoScaleRate;
                                }
                                // }

                                resetRotate();
                            }
                        }
                    });
            })();

            //---------------------------------------------------------------------------------------------------------
            // Keyboard axis view
            // Press 1,2,3,4,5 or 6 to view center of model from along an axis 
            //---------------------------------------------------------------------------------------------------------

            (function () {

                var flight = self.create({
                    type:&quot;xeogl.CameraFlightAnimation&quot;,
                    camera: camera,
                    duration: 1.0 // One second to fly to each new target
                });

                function fly(eye, look, up) {

                    rotatePos.set(look);

                    flying = true;

                    flight.cancel();

                    flight.flyTo({
                            look: look,
                            eye: eye,
                            up: up
                        },
                        function () {
                            resetRotate();

                            flying = false;
                        });
                }

                input.on(&quot;keydown&quot;,
                    function (keyCode) {

                        if (!input.mouseover) {
                            return;
                        }

                        if (mouseDown) {
                            return;
                        }

                        if (keyCode !== input.KEY_NUM_1
                            &amp;&amp; keyCode !== input.KEY_NUM_2
                            &amp;&amp; keyCode !== input.KEY_NUM_3
                            &amp;&amp; keyCode !== input.KEY_NUM_4
                            &amp;&amp; keyCode !== input.KEY_NUM_5
                            &amp;&amp; keyCode !== input.KEY_NUM_6) {
                            return;
                        }

                        var boundary = scene.worldBoundary;
                        var aabb = boundary.aabb;
                        var center = boundary.center;
                        var diag = math.getAABB3Diag(aabb);
                        var fitFOV = 55;
                        var dist = Math.abs((diag) / Math.tan(fitFOV/2));

                        switch (keyCode) {

                            case input.KEY_NUM_1: // Right view
                                fly(math.vec3([center[0] - dist, center[1], center[2]]), center, math.vec3([0, 0, 1]));
                                break;

                            case input.KEY_NUM_2: // Back view
                                fly(math.vec3([center[0], center[1] + dist, center[2]]), center, math.vec3([0, 0, 1]));
                                break;

                            case input.KEY_NUM_3: // Left view
                                fly(math.vec3([center[0] + dist, center[1], center[2]]), center, math.vec3([0, 0, 1]));
                                break;

                            case input.KEY_NUM_4: // Front view
                                fly(math.vec3([center[0], center[1] - dist, center[2]]), center, math.vec3([0, 0, 1]));
                                break;

                            case input.KEY_NUM_5: // Top view
                                fly(math.vec3([center[0], center[1], center[2] + dist]), center, math.vec3([0, 1, 0]));
                                break;

                            case input.KEY_NUM_6: // Bottom view
                                fly(math.vec3([center[0], center[1], center[2] - dist]), center, math.vec3([0, -1, 0]));
                                break;

                            default:
                                return;
                        }
                    });
            })();

            //---------------------------------------------------------------------------------------------------------
            // Keyboard pan camera
            // Press W,S,A or D to pan the camera 
            //---------------------------------------------------------------------------------------------------------

            scene.on(&quot;tick&quot;, (function () {

                var tempVec3 = math.vec3();

                return function (params) {

                    if (mouseDown) {
                        return;
                    }

                    if (!input.mouseover) {
                        return;
                    }

                    if (flying) {
                        return;
                    }

                    var elapsed = params.deltaTime;

                    if (!input.ctrlDown &amp;&amp; !input.altDown) {

                        var wkey = input.keyDown[input.KEY_W];
                        var skey = input.keyDown[input.KEY_S];
                        var akey = input.keyDown[input.KEY_A];
                        var dkey = input.keyDown[input.KEY_D];
                        var zkey = input.keyDown[input.KEY_Z];
                        var xkey = input.keyDown[input.KEY_X];

                        if (wkey || skey || akey || dkey || xkey || zkey) {

                            var x = 0;
                            var y = 0;
                            var z = 0;

                            var sceneSize = getSceneDiagSize();
                            var sensitivity = sceneSize / 4000.0;

                            if (skey) {
                                y = elapsed * sensitivity;
                            } else if (wkey) {
                                y = -elapsed * sensitivity;
                            }

                            if (dkey) {
                                x = elapsed * sensitivity;
                            } else if (akey) {
                                x = -elapsed * sensitivity;
                            }

                            if (xkey) {
                                z = elapsed * sensitivity;
                            } else if (zkey) {
                                z = -elapsed * sensitivity;
                            }

                            tempVec3[0] = x;
                            tempVec3[1] = y;
                            tempVec3[2] = z;

                            view.pan(tempVec3);

                            resetRotate();
                        }
                    }
                };
            })());
        },

        _props: {

            // The position we&#x27;re currently orbiting
            rotatePos: {

                set: function (value) {

                    if (value) {
                        this._rotatePos.set(value);
                    }
                }
            }
        }
    });
})();
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
