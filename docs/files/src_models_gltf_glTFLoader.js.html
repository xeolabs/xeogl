<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/models/gltf/glTFLoader.js - xeogl</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link href='https://fonts.googleapis.com/css?family=Exo+2:400,800,900,700,600,500|Roboto:100,300,400,500,700,900'  rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 class="projectTitle"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
                                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
                                <li><a href="../classes/Billboard.html">Billboard</a></li>
                                <li><a href="../classes/Boundary2D.html">Boundary2D</a></li>
                                <li><a href="../classes/Boundary3D.html">Boundary3D</a></li>
                                <li><a href="../classes/BoundingSphereGeometry.html">BoundingSphereGeometry</a></li>
                                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
                                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
                                <li><a href="../classes/Camera.html">Camera</a></li>
                                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
                                <li><a href="../classes/CameraController.html">CameraController</a></li>
                                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
                                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
                                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
                                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
                                <li><a href="../classes/Canvas.html">Canvas</a></li>
                                <li><a href="../classes/Clip.html">Clip</a></li>
                                <li><a href="../classes/Clips.html">Clips</a></li>
                                <li><a href="../classes/ColorBuf.html">ColorBuf</a></li>
                                <li><a href="../classes/Component.html">Component</a></li>
                                <li><a href="../classes/Configs.html">Configs</a></li>
                                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
                                <li><a href="../classes/Cull.html">Cull</a></li>
                                <li><a href="../classes/Curve.html">Curve</a></li>
                                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
                                <li><a href="../classes/DepthBuf.html">DepthBuf</a></li>
                                <li><a href="../classes/DirLight.html">DirLight</a></li>
                                <li><a href="../classes/Entity.html">Entity</a></li>
                                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
                                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
                                <li><a href="../classes/HeightmapGeometry.html">HeightmapGeometry</a></li>
                                <li><a href="../classes/Input.html">Input</a></li>
                                <li><a href="../classes/KeyboardAxisCamera.html">KeyboardAxisCamera</a></li>
                                <li><a href="../classes/KeyboardPanCamera.html">KeyboardPanCamera</a></li>
                                <li><a href="../classes/KeyboardRotateCamera.html">KeyboardRotateCamera</a></li>
                                <li><a href="../classes/KeyboardZoomCamera.html">KeyboardZoomCamera</a></li>
                                <li><a href="../classes/Layer.html">Layer</a></li>
                                <li><a href="../classes/Lights.html">Lights</a></li>
                                <li><a href="../classes/Lookat.html">Lookat</a></li>
                                <li><a href="../classes/Material.html">Material</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/Modes.html">Modes</a></li>
                                <li><a href="../classes/MousePanCamera.html">MousePanCamera</a></li>
                                <li><a href="../classes/MousePickEntity.html">MousePickEntity</a></li>
                                <li><a href="../classes/MouseRotateCamera.html">MouseRotateCamera</a></li>
                                <li><a href="../classes/MouseZoomCamera.html">MouseZoomCamera</a></li>
                                <li><a href="../classes/Nintendo3DSGeometry.html">Nintendo3DSGeometry</a></li>
                                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
                                <li><a href="../classes/OBJGeometry.html">OBJGeometry</a></li>
                                <li><a href="../classes/Ortho.html">Ortho</a></li>
                                <li><a href="../classes/Path.html">Path</a></li>
                                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
                                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
                                <li><a href="../classes/PointLight.html">PointLight</a></li>
                                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
                                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
                                <li><a href="../classes/Rotate.html">Rotate</a></li>
                                <li><a href="../classes/Scale.html">Scale</a></li>
                                <li><a href="../classes/Scene.html">Scene</a></li>
                                <li><a href="../classes/Skybox.html">Skybox</a></li>
                                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
                                <li><a href="../classes/Spinner.html">Spinner</a></li>
                                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
                                <li><a href="../classes/Stage.html">Stage</a></li>
                                <li><a href="../classes/Stationary.html">Stationary</a></li>
                                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
                                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
                                <li><a href="../classes/Texture.html">Texture</a></li>
                                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/Translate.html">Translate</a></li>
                                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
                                <li><a href="../classes/Viewport.html">Viewport</a></li>
                                <li><a href="../classes/Visibility.html">Visibility</a></li>
                                <li><a href="../classes/xeogl.html">xeogl</a></li>
                                <li><a href="../classes/xeogl.math.math.html">xeogl.math.math</a></li>
                                <li><a href="../classes/ZSpaceEffect.html">ZSpaceEffect</a></li>
                                <li><a href="../classes/ZSpaceStylusControl.html">ZSpaceStylusControl</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="..//modules/animation.html">animation</a></li>
                                <li><a href="..//modules/boundaries.html">boundaries</a></li>
                                <li><a href="..//modules/camera.html">camera</a></li>
                                <li><a href="..//modules/canvas.html">canvas</a></li>
                                <li><a href="..//modules/clipping.html">clipping</a></li>
                                <li><a href="..//modules/configs.html">configs</a></li>
                                <li><a href="..//modules/controls.html">controls</a></li>
                                <li><a href="..//modules/culling.html">culling</a></li>
                                <li><a href="..//modules/curves.html">curves</a></li>
                                <li><a href="..//modules/effects.html">effects</a></li>
                                <li><a href="..//modules/entities.html">entities</a></li>
                                <li><a href="..//modules/generation.html">generation</a></li>
                                <li><a href="..//modules/geometry.html">geometry</a></li>
                                <li><a href="..//modules/input.html">input</a></li>
                                <li><a href="..//modules/interaction.html">interaction</a></li>
                                <li><a href="..//modules/lighting.html">lighting</a></li>
                                <li><a href="..//modules/materials.html">materials</a></li>
                                <li><a href="..//modules/math.html">math</a></li>
                                <li><a href="..//modules/models.html">models</a></li>
                                <li><a href="..//modules/rendering.html">rendering</a></li>
                                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
                                <li><a href="..//modules/transforms.html">transforms</a></li>
                                <li><a href="..//modules/xeogl.html">xeogl</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
                    <!--Show:-->
                    <!--<label for="api-show-inherited">-->
                        <!--<input type="checkbox" id="api-show-inherited" checked>-->
                        <!--Inherited-->
                    <!--</label>-->
            
                    <!--<label for="api-show-protected">-->
                        <!--<input type="checkbox" id="api-show-protected">-->
                        <!--Protected-->
                    <!--</label>-->
            
                    <!--<label for="api-show-private">-->
                        <!--<input type="checkbox" id="api-show-private">-->
                        <!--Private-->
                    <!--</label>-->
                    <!--<label for="api-show-deprecated">-->
                        <!--<input type="checkbox" id="api-show-deprecated">-->
                        <!--Deprecated-->
                    <!--</label>-->
            
                <!--</div>-->
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/models/gltf/glTFLoader.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Private xeogl glTF loader core.
 *
 * Adapted from the THREE loader by Tony Parisi (http://www.tonyparisi.com)
 * https://github.com/KhronosGroup/glTF/blob/master/loaders/threejs/glTFLoaderUtils.js
 */
(function () {

    &quot;use strict&quot;;

    function log(type, entryId, description) {
        console.log(type + &quot;: &quot; + entryId + &quot;: &quot; + JSON.stringify(description, null, 4));
    }

    // Resource management

    var ResourceEntry = function (entryID, object, description) {
        this.entryID = entryID;
        this.object = object;
        this.description = description;
    };

    var Resources = function () {
        this._entries = {};
    };

    Resources.prototype.setEntry = function (entryID, object, description) {
        if (!entryID) {
            console.error(&quot;No EntryID provided, cannot store&quot;, description);
            return;
        }

        if (this._entries[entryID]) {
            console.warn(&quot;entry[&quot; + entryID + &quot;] is being overwritten&quot;);
        }

        this._entries[entryID] = new ResourceEntry(entryID, object, description);
    };

    Resources.prototype.getEntry = function (entryID) {
        return this._entries[entryID];
    };

    Resources.prototype.clearEntries = function () {
        this._entries = {};
    };

    // Delegate for processing index buffers
    var IndicesDelegate = function () {
    };

    IndicesDelegate.prototype.handleError = function (errorCode, info) {
        // FIXME: report error
        console.log(&quot;ERROR(IndicesDelegate):&quot; + errorCode + &quot;:&quot; + info);
    };

    IndicesDelegate.prototype.convert = function (resource, ctx) {
        return new Uint16Array(resource, 0, ctx.indices.count);
    };

    IndicesDelegate.prototype.resourceAvailable = function (glResource, ctx) {
        var geometry = ctx.geometry;
        geometry.indices = glResource;
        //geometry.checkFinished();
        return true;
    };

    function componentsPerElementForGLType(type) {

        var nElements = 0;

        switch (type) {
            case &quot;SCALAR&quot; :
                nElements = 1;
                break;
            case &quot;VEC2&quot; :
                nElements = 2;
                break;
            case &quot;VEC3&quot; :
                nElements = 3;
                break;
            case &quot;VEC4&quot; :
                nElements = 4;
                break;
            case &quot;MAT2&quot; :
                nElements = 4;
                break;
            case &quot;MAT3&quot; :
                nElements = 9;
                break;
            case &quot;MAT4&quot; :
                nElements = 16;
                break;
            default :
                debugger;
                break;
        }

        return nElements;
    }

    var indicesDelegate = new IndicesDelegate();

    var IndicesContext = function (indices, geometry) {
        this.indices = indices;
        this.geometry = geometry;
    };

    // Delegate for processing vertex attribute buffers
    var VertexAttributeDelegate = function () {
    };

    VertexAttributeDelegate.prototype.handleError = function (errorCode, info) {
        // FIXME: report error
        console.log(&quot;ERROR(VertexAttributeDelegate):&quot; + errorCode + &quot;:&quot; + info);
    };

    VertexAttributeDelegate.prototype.convert = function (resource, ctx) {
        return resource;
    };

    VertexAttributeDelegate.prototype.resourceAvailable = function (glResource, ctx) {

        var geometry = ctx.geometry;
        var attribute = ctx.attribute;
        var semantic = ctx.semantic;

        //FIXME: Float32 is assumed here, but should be checked.

        if (semantic === &quot;POSITION&quot;) {
            geometry.positions = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));

        } else if (semantic === &quot;NORMAL&quot;) {
            geometry.normals = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));

        } else if ((semantic === &quot;TEXCOORD_0&quot;) || (semantic === &quot;TEXCOORD&quot; )) {
            geometry.uv = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));
        }

        geometry.loadedAttributes++;

        //geometry.checkFinished();

        return true;
    };

    var vertexAttributeDelegate = new VertexAttributeDelegate();

    var VertexAttributeContext = function (attribute, semantic, geometry) {
        this.attribute = attribute;
        this.semantic = semantic;
        this.geometry = geometry;
    };


    xeogl.GLTFLoader = Object.create(xeogl.glTFParser, {

        setModel: {
            value: function (model) {
                this.model = model;
            }
        },

        load: {
            enumerable: true,
            value: function (userInfo, options, ok) {

                if (!this.model) {
                    throw &quot;model not set&quot;;
                }

                this.resources = new Resources();

                xeogl.glTFParser.handleLoadCompleted = ok;
                xeogl.glTFParser.load.call(this, userInfo, options);
            }
        },

        _makeID: {
            value: function (entryID) {
                // https://github.com/KhronosGroup/glTF/blob/master/specification/README.md#ids-and-names
                return this._idPrefix + &quot;#&quot; + entryID;
            }
        },

        handleBuffer: {
            value: function (entryID, description, userInfo) {
                this.resources.setEntry(entryID, null, description);
                description.type = &quot;ArrayBuffer&quot;;
                return true;
            }
        },

        handleBufferView: {
            value: function (entryID, description, userInfo) {
                this.resources.setEntry(entryID, null, description);

                var buffer = this.resources.getEntry(description.buffer);
                description.type = &quot;ArrayBufferView&quot;;

                var bufferViewEntry = this.resources.getEntry(entryID);
                bufferViewEntry.buffer = buffer;
                return true;
            }
        },

        handleAccessor: {
            value: function (entryID, description, userInfo) {
                this.resources.setEntry(entryID, description, description);
                return true;
            }
        },

        handleTexture: {
            value: function (entryID, description, userInfo) {

                if (!description.source) {
                    return;
                }

                var image = this._json.images[description.source];

                var texture = new xeogl.Texture(this.model.scene, {
                    id: this._makeID(entryID),
                    src: image.uri,
                    flipY: true
                });

                this.model.add(texture);

                this.resources.setEntry(entryID, texture, description);

                return true;
            }
        },

        handleMaterial: {
            value: function (entryID, description, userInfo) {

                //   log(&quot;material&quot;, entryID, description);

                var values = description.values || {};

                var diffuseVal = values.diffuse;
                var specularVal = values.specular;
                var shininessVal = values.shininess;
                var emissiveVal = values.emission;

                var cfg = {
                    id: this._makeID(entryID),
                    meta: {
                        userInfo: userInfo
                    },
                    shininess: shininessVal
                };

                var entry;

                if (diffuseVal) {
                    if (xeogl._isString(diffuseVal)) {
                        entry = this.resources.getEntry(diffuseVal);
                        if (entry) {
                            cfg.diffuseMap = entry.object;
                        }
                    } else {
                        cfg.diffuse = diffuseVal.slice(0, 3);
                    }
                }

                if (specularVal) {
                    if (xeogl._isString(specularVal)) {
                        entry = this.resources.getEntry(specularVal);
                        if (entry) {
                            cfg.specularMap = entry.object;
                        }
                    } else {
                        cfg.specular = specularVal.slice(0, 3);
                    }
                }

                if (emissiveVal) {
                    if (xeogl._isString(emissiveVal)) {
                        entry = this.resources.getEntry(emissiveVal);
                        if (entry) {
                            cfg.emissiveMap = entry.object;
                        }
                    } else {
                        cfg.emissive = emissiveVal.slice(0, 3);
                    }
                }

                var material = new xeogl.PhongMaterial(this.model.scene, cfg);

                this.model.add(material);

                this.resources.setEntry(entryID, material, description);

                return true;
            }
        },

        handleLight: {
            value: function (entryID, description, userInfo) {
                log(&quot;light&quot;, entryID, description);
                return true;
            }
        },

        handleMesh: {
            value: function (entryID, description, userInfo) {

                var mesh = [];

                this.resources.setEntry(entryID, mesh, description);

                var primitivesDescription = description.primitives;

                if (!primitivesDescription) {
                    //FIXME: not implemented in delegate
                    log(&quot;MISSING_PRIMITIVES for mesh:&quot; + entryID);
                    return false;
                }

                for (var i = 0; i &lt; primitivesDescription.length; i++) {
                    var primitiveDescription = primitivesDescription[i];

                    if (primitiveDescription.mode === WebGLRenderingContext.TRIANGLES) {

                        var geometry = new xeogl.Geometry(this.model.scene, {
                            id: this._makeID(entryID)
                        });

                        this.model.add(geometry);

                        var materialEntry = this.resources.getEntry(primitiveDescription.material);
                        var material = materialEntry.object;

                        mesh.push({
                            geometry: geometry,
                            material: material
                        });

                        var allAttributes = Object.keys(primitiveDescription.attributes);

                        // count them first, async issues otherwise
                        geometry.totalAttributes += allAttributes.length;

                        var indices = this.resources.getEntry(primitiveDescription.indices);
                        var bufferEntry = this.resources.getEntry(indices.description.bufferView);
                        var indicesObject = {
                            bufferView: bufferEntry,
                            byteOffset: indices.description.byteOffset,
                            count: indices.description.count,
                            id: indices.entryID,
                            componentType: indices.description.componentType,
                            type: indices.description.type
                        };

                        var indicesContext = new IndicesContext(indicesObject, geometry);
                        var alreadyProcessedIndices = xeogl.GLTFLoaderUtils.getBuffer(indicesObject, indicesDelegate, indicesContext);

                        // Load Vertex Attributes
                        allAttributes.forEach(function (semantic) {

                            var attribute;
                            var attributeID = primitiveDescription.attributes[semantic];
                            var attributeEntry = this.resources.getEntry(attributeID);
                            var bufferEntry;

                            if (!attributeEntry) {

                                //let&#x27;s just use an anonymous object for the attribute
                                attribute = description.attributes[attributeID];
                                attribute.id = attributeID;
                                this.resources.setEntry(attributeID, attribute, attribute);

                                bufferEntry = this.resources.getEntry(attribute.bufferView);
                                attributeEntry = this.resources.getEntry(attributeID);

                            } else {
                                attribute = attributeEntry.object;
                                attribute.id = attributeID;
                                bufferEntry = this.resources.getEntry(attribute.bufferView);
                            }

                            var attributeObject = {
                                bufferView: bufferEntry,
                                byteOffset: attribute.byteOffset,
                                byteStride: attribute.byteStride,
                                count: attribute.count,
                                max: attribute.max,
                                min: attribute.min,
                                componentType: attribute.componentType,
                                type: attribute.type,
                                id: attributeID
                            };

                            var attribContext = new VertexAttributeContext(attributeObject, semantic, geometry);

                            var alreadyProcessedAttribute = xeogl.GLTFLoaderUtils.getBuffer(attributeObject, vertexAttributeDelegate, attribContext);

                            /*if(alreadyProcessedAttribute) {
                             vertexAttributeDelegate.resourceAvailable(alreadyProcessedAttribute, attribContext);
                             }*/

                        }, this);
                    }
                }

                return true;
            }
        },

        handleCamera: {
            value: function (entryID, description, userInfo) {
                //log(&quot;camera&quot;, entryID, description);
                return true;
            }
        },

        handleScene: {
            value: function (entryID, description, userInfo) {

                var nodes = description.nodes;

                if (nodes) {

                    var node;
                    var transform;

                    for (var nodeId in nodes) {
                        if (nodes.hasOwnProperty(nodeId)) {

                            node = nodes [nodeId];
                            transform = null;

                            this._parseNode(node, transform);
                        }
                    }
                }
            }
        },

        _parseNode: {
            value: function (nodeId, transform) {

                var node = this._json.nodes[nodeId];

                if (!node) {
                    return;
                }

                var model = this.model;
                var scene = model.scene;

                if (node.matrix) {
                    var matrix = node.matrix;
                    transform = new xeogl.Transform(scene, {
                        id: this._makeID(nodeId + &quot;.transform&quot;),
                        matrix: matrix,
                        parent: transform
                    });
                    model.add(transform);
                }

                if (node.translation) {
                    var translation = node.translation;
                    transform = new xeogl.Translate(scene, {
                        id: this._makeID(nodeId + &quot;.translation&quot;),
                        xyz: [translation[0], translation[1], translation[2]],
                        parent: transform
                    });
                    model.add(transform);
                }

                if (node.rotation) {
                    var rotation = node.rotation;
                    transform = new xeogl.Rotate(scene, {
                        id: this._makeID(nodeId + &quot;.rotation&quot;),
                        xyz: [rotation[0], rotation[1], rotation[2]],
                        angle: rotation[3],
                        parent: transform
                    });
                    model.add(transform);
                }

                if (node.scale) {
                    var scale = node.scale;
                    transform = new xeogl.Scale(scene, {
                        id: this._makeID(nodeId + &quot;.scale&quot;),
                        xyz: [scale[0], scale[1], scale[2]],
                        parent: transform
                    });
                    model.add(transform);
                }

                if (node.meshes) {

                    // One xeogl.Visibility per mesh group

                    var visibility = new xeogl.Visibility(scene, {
                        id: this._makeID(nodeId + &quot;.visibility&quot;)
                    });

                    model.add(visibility);

                    // One xeogl.Cull per mesh group

                    var cull = new xeogl.Cull(scene, {
                        id: this._makeID(nodeId + &quot;.cull&quot;)
                    });

                    model.add(cull);

                    // One xeogl.Modes per mesh group

                    var modes = new xeogl.Modes(scene, {
                        id: this._makeID(nodeId + &quot;.modes&quot;)
                    });

                    model.add(cull);

                    // One xeogl.Entity per mesh, each sharing the same
                    // xeogl.Visibility, xeogl.Cull and xeogl.Nodes

                    var meshes = node.meshes;
                    var imeshes;
                    var lenMeshes = meshes.length;
                    var mesh;
                    var i;
                    var len;
                    var material;
                    var geometry;
                    var entityId;
                    var j;
                    var entities = scene.types[&quot;xeogl.Entity&quot;];
                    var entity;

                    for (imeshes = 0; imeshes &lt; lenMeshes; imeshes++) {

                        mesh = this.resources.getEntry(meshes[imeshes]);

                        if (!mesh) {
                            continue;
                        }

                        mesh = mesh.object;

                        for (i = 0, len = mesh.length; i &lt; len; i++) {

                            material = mesh[i].material;
                            geometry = mesh[i].geometry;

                            entityId = this._makeID(nodeId + &quot;.entity.&quot; + i);

                            //// Fake ID when clashing with existing entity ID
                            //for  (j = 0; entities[entityId]; j++) {
                            //    entityId = this._makeID(nodeId + &quot;.entity.&quot; + i + &quot;.&quot; + j);
                            //}

                            entity = new xeogl.Entity(scene, {
                                id: entityId,
                                meta: {
                                    name: node.name
                                },
                                material: material,
                                geometry: geometry,
                                transform: transform,
                                visibility: visibility,
                                cull: cull,
                                modes: modes,

                                // Indicates that this Entity is freshly loaded -  increments the xeogl.Spinner#processes
                                // count on the Scene Canvas, which will decrement again as soon as Entity is compiled
                                // into the render graph, causing the Spinner to show until this Entity is visible
                                loading: true
                            });

                            model.add(entity);
                        }
                    }
                }

                if (node.children) {

                    var children = node.children;
                    var childNode;

                    for (i = 0, len = children.length; i &lt; len; i++) {
                        childNode = children[i];
                        this._parseNode(childNode, transform);
                    }
                }

                return true;
            }
        }
    });

})();
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
